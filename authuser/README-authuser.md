## IMPL DA API AUTH USER
- Criar projeto Spring pelo initialzr, importando spring web, jpa, lombok e postgres
- Configurar application.yaml com as configurações de banco e hibernate
- Criar pacote models onde irão ser salvos os modelos(entidades) do projeto:
    - Neste caso, primeimo model é chamado UserModel
    - Anotar entidate como @Entity para informar que a classe será gerenciada pelo Spring e @Table para a geração deste objeto no banco de dados.
    - Utilizamos UUID pois é um tipo de ID único e utlizado universalment. A chance de geração de um mesmo UUID é minimamente irrelevante.
    - Utilizamos LocalDateTime para salvar a data de criacao e atualizacao do objeto no banco.
    - Para id utlizamos a anotação @id, @generatedValue(strategy=Generation.Type.AUTO)
    - Utlizar anotações convenientes para o resto dos atributos.
    - Utilizamos @Data(do lombok) como anotação da classe para nao ser preciso criar os metodos getters, setters, construtores, toString...
- Criar pacote respository e UserRepository para o model criado
- Criar pacote services e interface UserService para a criacao de de metodos q serao utlizados para a criação do crud do modelo criado
- Criar pacote serviceImpl dentro de service e a classe UserServiceImpl para a implementacao dos metodos da interface Service
- Criar pacote controllers e UserController
    - Utilizamos @RestController para o spring gerenciar como um Bean
    - Utilizamos @CrossOrigin(origins="*") a nivel de classe, para esse controller ser acessado de qualquer lugar
    - Utilizamos @RequestMapping("/users") para definir por qual URI este controller será acessado
    - Injetamos o UserSerice por @Autoriwed.
    - Criamos metodos getAll, getOne e deleteOne e implementamos seus respectivos metodos no UserService, UserServiceImpl e UserRepository(se necessario).
    - Sempre retornando um ResponseEntity, utlizando http status e body especifico para cada tipo de retorno
- Criar AuthenticationController q sera responsavel por cadastrar, editar, autenticar e autorizar cada usuario:
    - Utilizar @RestController @CrossOrigin(origins="*") e @RequestMapping("/auth")
    - Criar UserDTO para receber os dados de entrada do cliente, para assim verificar os campos e só depois de estar tudo ok transformar este DTO em objeto user para o salvamento do mesmo em banco.
    - Anotar dto como @Data e @JsonInclude(JsonInclude.Include.NON_NULL)
    - Criar metódos registerUser no AuthController e medotos especificos no UserSerive e UserRepository
- Dentro da classe UserDTO:
     -  Criar interface UserView com as diferentes visões de alterações do usuário(sejam elas um cadastro, edicao de dados, edicao de password,etc)
     -  Utilizar @JsonView em cada atributo especificando qual a visão(UserView) 
     - Anotar com @JsonView nos metodos dos controllers q irão receber o objeto User do client para cadastro e update do objeto.
- Utilizar a biblioteca SpringValidation(no pom) para validar campos de UserDTO
- Utilizamos uma anotacao customizada @UsernameConstraint para efetuar uma validação que podemos customizar de acordo com o que o sistema irá pedir, para isso:
    - Anotar username como @UsernameConstrain e passar o group de visão (UserView)
    - Criar pacote validation
    - Dentro do pacote validation, criar a @interface UsernameConstraint com as determinadas anotações de classe
    - Definir atributos default: message, groups e payload
    - Criar classe UsernameConstraintImpl, que irá implementar ConstraintValidator< UsernameConstraint, String >
    - Em UsernameConstraintImpl, implementar metodos default e desenvolver a regra de negocio no método isValid, retornando false se nao for validado.
- Implementação de retorno com paginação utlizando Spring Data:
    - Em UserController mudar retorno para o time ResponseEntity< Page < UserModel > >
    - Receber um Pageable (da biblioteca .data.domain) como parametro
    - Anotar o Pageable como @PageableDefault e passar as definições da paginação entre parenteses
    - Criar nova funcao findAll em UserService, só que agora recebendo um Pageable como parametro
    - Implementar funcao findAll em UserServiceImpl, utlizando a funcao nativa de JPA que irá realizar um findAll porém recebendo um Pageable como parametro
    - Dentro de getAllUsers em UserController, inicializar um objeto Page que irá receber o retorno desse novo findAll de UserService
    - Dentro do body, retornar o objeto Page
    - Obs: Para mudar os paramentros da paginação, basta que sejam modificados via Params na própria requisição